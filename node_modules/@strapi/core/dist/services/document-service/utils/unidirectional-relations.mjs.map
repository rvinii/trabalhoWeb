{"version":3,"file":"unidirectional-relations.mjs","sources":["../../../../src/services/document-service/utils/unidirectional-relations.ts"],"sourcesContent":["/* eslint-disable no-continue */\nimport { keyBy } from 'lodash/fp';\n\nimport { UID, Schema } from '@strapi/types';\n\n/**\n * Loads lingering relations that need to be updated when overriding a published or draft entry.\n * This is necessary because the relations are uni-directional and the target entry is not aware of the source entry.\n * This is not the case for bi-directional relations, where the target entry is also linked to the source entry.\n *\n * @param uid The content type uid\n * @param oldEntries The old entries that are being overridden\n * @returns An array of relations that need to be updated with the join table reference.\n */\nconst load = async (uid: UID.ContentType, oldEntries: { id: string; locale: string }[]) => {\n  const updates = [] as any;\n\n  // Iterate all components and content types to find relations that need to be updated\n  await strapi.db.transaction(async ({ trx }) => {\n    const contentTypes = Object.values(strapi.contentTypes) as Schema.ContentType[];\n    const components = Object.values(strapi.components) as Schema.Component[];\n\n    for (const model of [...contentTypes, ...components]) {\n      const dbModel = strapi.db.metadata.get(model.uid);\n\n      for (const attribute of Object.values(dbModel.attributes) as any) {\n        /**\n         * Only consider unidirectional relations\n         */\n        if (attribute.type !== 'relation') continue;\n        if (attribute.target !== uid) continue;\n        if (attribute.inversedBy || attribute.mappedBy) continue;\n        const joinTable = attribute.joinTable;\n        // TODO: joinColumn relations\n        if (!joinTable) continue;\n\n        const { name } = joinTable.inverseJoinColumn;\n\n        /**\n         * Load all relations that need to be updated\n         */\n        const oldEntriesIds = oldEntries.map((entry) => entry.id);\n        const relations = await strapi.db\n          .getConnection()\n          .select('*')\n          .from(joinTable.name)\n          .whereIn(name, oldEntriesIds)\n          .transacting(trx);\n\n        if (relations.length === 0) continue;\n\n        updates.push({ joinTable, relations });\n      }\n    }\n  });\n\n  return updates;\n};\n\n/**\n * Updates uni directional relations to target the right entries when overriding published or draft entries.\n *\n * @param oldEntries The old entries that are being overridden\n * @param newEntries The new entries that are overriding the old ones\n * @param oldRelations The relations that were previously loaded with `load` @see load\n */\nconst sync = async (\n  oldEntries: { id: string; locale: string }[],\n  newEntries: { id: string; locale: string }[],\n  oldRelations: { joinTable: any; relations: any[] }[]\n) => {\n  /**\n   * Create a map of old entry ids to new entry ids\n   *\n   * Will be used to update the relation target ids\n   */\n  const newEntryByLocale = keyBy('locale', newEntries);\n  const oldEntriesMap = oldEntries.reduce(\n    (acc, entry) => {\n      const newEntry = newEntryByLocale[entry.locale];\n      if (!newEntry) return acc;\n      acc[entry.id] = newEntry.id;\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  await strapi.db.transaction(async ({ trx }) => {\n    const con = strapi.db.getConnection();\n\n    // Iterate old relations that are deleted and insert the new ones\n    for (const { joinTable, relations } of oldRelations) {\n      // Update old ids with the new ones\n      const newRelations = relations.map((relation) => {\n        const column = joinTable.inverseJoinColumn.name;\n        const newId = oldEntriesMap[relation[column]];\n        return { ...relation, [column]: newId };\n      });\n\n      // Insert those relations into the join table\n      await con.batchInsert(joinTable.name, newRelations).transacting(trx);\n    }\n  });\n};\n\nexport { load, sync };\n"],"names":[],"mappings":";AAcM,MAAA,OAAO,OAAO,KAAsB,eAAiD;AACzF,QAAM,UAAU,CAAA;AAGhB,QAAM,OAAO,GAAG,YAAY,OAAO,EAAE,UAAU;AAC7C,UAAM,eAAe,OAAO,OAAO,OAAO,YAAY;AACtD,UAAM,aAAa,OAAO,OAAO,OAAO,UAAU;AAElD,eAAW,SAAS,CAAC,GAAG,cAAc,GAAG,UAAU,GAAG;AACpD,YAAM,UAAU,OAAO,GAAG,SAAS,IAAI,MAAM,GAAG;AAEhD,iBAAW,aAAa,OAAO,OAAO,QAAQ,UAAU,GAAU;AAIhE,YAAI,UAAU,SAAS;AAAY;AACnC,YAAI,UAAU,WAAW;AAAK;AAC1B,YAAA,UAAU,cAAc,UAAU;AAAU;AAChD,cAAM,YAAY,UAAU;AAE5B,YAAI,CAAC;AAAW;AAEV,cAAA,EAAE,KAAK,IAAI,UAAU;AAK3B,cAAM,gBAAgB,WAAW,IAAI,CAAC,UAAU,MAAM,EAAE;AACxD,cAAM,YAAY,MAAM,OAAO,GAC5B,gBACA,OAAO,GAAG,EACV,KAAK,UAAU,IAAI,EACnB,QAAQ,MAAM,aAAa,EAC3B,YAAY,GAAG;AAElB,YAAI,UAAU,WAAW;AAAG;AAE5B,gBAAQ,KAAK,EAAE,WAAW,UAAW,CAAA;AAAA,MACvC;AAAA,IACF;AAAA,EAAA,CACD;AAEM,SAAA;AACT;AASA,MAAM,OAAO,OACX,YACA,YACA,iBACG;AAMG,QAAA,mBAAmB,MAAM,UAAU,UAAU;AACnD,QAAM,gBAAgB,WAAW;AAAA,IAC/B,CAAC,KAAK,UAAU;AACR,YAAA,WAAW,iBAAiB,MAAM,MAAM;AAC9C,UAAI,CAAC;AAAiB,eAAA;AAClB,UAAA,MAAM,EAAE,IAAI,SAAS;AAClB,aAAA;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EAAA;AAGH,QAAM,OAAO,GAAG,YAAY,OAAO,EAAE,UAAU;AACvC,UAAA,MAAM,OAAO,GAAG,cAAc;AAGpC,eAAW,EAAE,WAAW,UAAU,KAAK,cAAc;AAEnD,YAAM,eAAe,UAAU,IAAI,CAAC,aAAa;AACzC,cAAA,SAAS,UAAU,kBAAkB;AAC3C,cAAM,QAAQ,cAAc,SAAS,MAAM,CAAC;AAC5C,eAAO,EAAE,GAAG,UAAU,CAAC,MAAM,GAAG,MAAM;AAAA,MAAA,CACvC;AAGD,YAAM,IAAI,YAAY,UAAU,MAAM,YAAY,EAAE,YAAY,GAAG;AAAA,IACrE;AAAA,EAAA,CACD;AACH;"}